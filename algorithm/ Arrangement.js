/*
01_getType
임의의 값을 입력받아 타입을 리턴해야 합니다.
*/

function getType(anything) {
  // 수도코드
	// 받아온 파라미터를 타입오브로 리턴한다.
  // array, null 나머지, 기본타입일때
  let result = '';


  // 만약에 anything array 타입이라면 
  if(Array.isArray(anything)){
    result = 'array';

  // 만약에 anything null 이라면
  } else if(anything === null){

    //'null'을 result에 저장해라.
    result = 'null'

  // 아닐때
  } else {

    // 해당하는 기본 타입을 result에 저장해라.
    result = typeof anything;
  }
  
	return result;

}


//----------------------------------------------------------------------------------------------------


/*
02_getFirstElement
배열을 입력받아 배열의 첫번째 요소를 리턴해야 합니다.
*/

function getFirstElement(arr) {
  // 수도코드
  // 파라미터로 입력받은 배열의 첫번째 인덱스에 해당하는 값을 리턴한다.
  return arr[0];
}


//----------------------------------------------------------------------------------------------------


/*
03_getLastElement
배열를 입력받아 배열의 마지막 요소를 리턴해야 합니다.
*/
function getLastElement(arr) {
  
  return arr[arr.length - 1];

}


//----------------------------------------------------------------------------------------------------


/*
04_getNthElement
배열과 수를 입력받아 수가 인덱스로 가리키는 배열의 요소를 리턴해야 합니다.
*/

function getNthElement(arr, num) {
  // 수도코드
  // 만약 배열 크기 이상의 num을 받았다면, 'out of index range'를 리턴
  // arr배열의 num번째 인덱스 값을 리턴한다.

  if(arr.length === 0){
    return undefined;
  }

  if(num > arr.length -1){
    return 'out of index range';

  } else {
    return arr[num];
  }


}


//----------------------------------------------------------------------------------------------------


/*
05_computeSumOfAllElements
배열을 입력받아 배열의 모든 요소의 합을 리턴해야 합니다.
*/

function computeSumOfAllElements(arr) {
  // 수도코드
  // 반복문을 통해 모든 배열 인덱스에 접근한다.

  // 반복한다. 배열의 길이보다 작을 동안 반복한다.
  // 반복하는 동안. 모든 요소의 합을 더한다.
  // 리턴한다. 모든 요소의 합.

  let total = 0;

  // 반복한다. 배열의 길이보다 작을 동안 반복한다.
  for(let i = 0; i < arr.length; i++){

    // 반복하는 동안. 모든 요소의 합을 더한다.
    total = total + arr[i];
  }

  // 리턴한다. 모든 요소의 합.
  return total;
}

//----------------------------------------------------------------------------------------------------


/*
06_getAllWords
문자열을 입력받아 문자열을 구성하는 각 단어를 요소로 갖는 배열을 리턴해야 합니다.
*/

function getAllWords(str) {
  // 수도코드 
  // '동해물과' '백두산이' '마르고';
  // 공백을 찾아야한다!


  //빈 문자일 경우 빈 배열을 리턴한다. 
  // 반복한다. 배열의 길이의+1 만큼 반복한다.
    // 문자를 문자열 변수에 저장한다.
    // 반복을 하다가 만약에 str의 인덱스[i]값이 공백이라면 
    // 새로운 배열 값에 문자열을 저장한다. 
  // 리턴한다. 모든 요소의 합.

  let s = '';
  let total = [];

  //빈 문자일 경우 빈 배열을 리턴한다. 
  if(str.length === 0){
    return total = [];
  }

  // 반복한다. 배열의 길이보다 작을 동안 반복한다.
  for(let i = 0; i <= str.length; i++){

  
    // 저장하는 중에 만약 str[i]값이 공백이라면
    // '해' + '물' + ' '
    if(str[i] === ' ' || i === str.length){

      // 첫번째 배열 값에 s를 저장한다. 
      // let total = ['동해물 ', '백두산이 '];
      total.push(s);

      // s변수를 초기화 시킨다.
      s = '';  
      
    // 공백이 아니라면.
    } else {
      // str의 모든 인덱스 값을 s변수에 저장한다.
      // '동' + '해' + '물' ....
      s = s + str[i];
    }

  }

  return total;

}


//----------------------------------------------------------------------------------------------------


/*
07_getAllLetters
문자열을 입력받아 문자열을 구성하는 각 문자를 요소로 갖는 배열을 리턴해야 합니다.
*/

function getAllLetters(str) {
  // 수도코드 
  // '동해물과 백두산이 마르고';
  //  '동', '해', '물', '과'
  
  // 반복한다. 배열의 길이만큼
    // 반복하는 동안 문자열의 i번째 인덱스를 total 배열에 저장한다.

  let total = []

  for(let i of str){
    total.push(i);
  }

  return total;

}


//----------------------------------------------------------------------------------------------------


/*
08_getLargestElement
배열을 입력받아 가장 큰 요소를 리턴해야 합니다.
*/

function getLargestElement(arr) {
  // 수도코드
  // 가장 큰 요소를 저장할 변수 max선언하고 arr[0]저장.
  // 반복한다. 입력받은 배열의 크기-1 만큼 반복한다.
    // 반복하는 동안, 만약 i번째 요소가 max보다 클 경우 max에 요소를 저장
  
  let max = arr[0];

  for(let i = 1; i < arr.length; i++){
    if(arr[i] > max){
      max = arr[i]
    }
  }

  return max;

}


//----------------------------------------------------------------------------------------------------


/*
09_getLongestWord
문자열을 입력받아 문자열에서 가장 긴 단어를 리턴해야 합니다.
*/

function getLongestWord(str) {
  // 수도코드
  
  // split배열을 선언 하고 입력받은 문자열을 공백을 기준으로 잘라 저장한다.
  // 가장 긴 문자열을 저장할 변수 long을 선언하고 split[0]번을 저장한다.
  // 배열의 길이만큼 반복한다.
    // 만약 배열의 i번째 요소의 길이가 long의 길이보다 길면, long에 요소를 저장한다.
  
  let split = str.split(' ');
  let long = split[0];

  for(let i of split){
    alert(i)
    if(i.length > long.length){
      long = i;
    }
  }
    
  return long;

}


//----------------------------------------------------------------------------------------------------


/*
10_getEvenNumbers
수를 요소로 갖는 배열을 입력받아 짝수만을 요소로 갖는 배열을 리턴해야 합니다.
*/

function getEvenNumbers(arr) {
  // 수도코드
  // 시간이 없는 관계로 이하 생략

  let even = []
  
  for(let i of arr){
    if(i % 2 === 0){
      even.push(i)
    }
  }


  return even;

}


//----------------------------------------------------------------------------------------------------


/*
11_addToFront
배열과 요소를 입력받아 주어진 요소를 배열의 맨 앞에 추가하고 해당 배열을 리턴해야 합니다.
*/

function addToFront(arr, el) {
  // 수도코드
  // 시간이 없는 관계로 이하 생략

  arr.unshift(el);

  return arr;

}


//----------------------------------------------------------------------------------------------------


/*
12_addToBack
배열과 요소를 입력받아 주어진 요소를 배열의 맨 뒤에 추가하고 해당 배열을 리턴해야 합니다.
*/

function addToBack(arr, el) {

  // 수도코드
  // 시간이 없는 관계로 이하 생략

  arr.push(el);

  return arr;

}


//----------------------------------------------------------------------------------------------------


/*
13_mergeArrays
배열과 인덱스를 입력받아 주어진 인덱스 이후의 요소들을 갖는 새로운 배열을 리턴해야 합니다.*/

function mergeArrays(arr1, arr2) {

  // 수도코드
  // 시간이 없는 관계로 이하 생략
  
  let arr = arr1.concat(arr2);
  return arr;
  
  }


//----------------------------------------------------------------------------------------------------


/*
15_getElementsUpTo
배열과 인덱스를 입력받아 주어진 인덱스 이전의 요소들을 갖는 새로운 배열을 리턴해야 합니다
*/

function getElementsUpTo(arr, n) {

  // 수도코드
  // 시간이 없는 관계로 이하 생략
  
  if(n > arr.length){
    return []
  }

  return arr.slice(0, n)

  }

    
//----------------------------------------------------------------------------------------------------


/*
16_getAllElementsButFirst
배열을 입력받아 배열의 첫번째 요소를 제외한 배열을 리턴해야 합니다.
*/

function getAllElementsButFirst(arr) {

  // 수도코드
  // 시간이 없는 관계로 이하 생략
  
  arr.shift();

  return arr;

  }



  
//----------------------------------------------------------------------------------------------------


/*
17_getAllElementsButLast
배열을 입력받아 마지막 요소를 제외한 배열을 리턴해야 합니다.
*/

function getAllElementsButLast(arr) {
  // 수도코드
  // 시간이 없는 관계로 이하 생략
  
  arr.pop();

  return arr;

  }



  
//----------------------------------------------------------------------------------------------------


/*
18_removeFromFront
배열을 입력받아 배열의 첫번째 요소가 삭제된 배열을 리턴해야 합니다.
*/

function removeFromFront(arr) {

  // 수도코드
  // 시간이 없는 관계로 이하 생략
  
  arr.shift();

  return arr;

  }


//----------------------------------------------------------------------------------------------------


/*
19_removeFromBack
배열을 입력받아 배열의 마지막 요소를 삭제한 배열을 리턴해야 합니다.
*/

function removeFromBack(arr) {
  // 수도코드
  // 시간이 없는 관계로 이하 생략
  
  arr.pop();

  return arr;

  }


//----------------------------------------------------------------------------------------------------


/*
20_removeFromBackOfNew
배열을 입력받아 배열의 마지막 요소가 제외된 새로운 배열을 리턴해야 합니다.
*/

function removeFromBackOfNew(arr) {
  // 수도코드
  // 시간이 없는 관계로 이하 생략
  

  let array = arr.slice(0,arr.length-1);

  return array;

  }

//----------------------------------------------------------------------------------------------------


/*
21_addToBackOfNew
배열과 요소를 입력받아 새로운 요소가 추가된 새로운 배열을 리턴해야 합니다.
*/

function addToBackOfNew(arr, el) {
  // 수도코드
  // 시간이 없는 관계로 이하 생략
  
  let array = arr.slice(0);

  array.push(el)

  return array;

}


//----------------------------------------------------------------------------------------------------


/*
22_addToFrontOfNew
배열과 요소를 입력받아 맨앞에 새로운 요소가 추가된 새로운 배열을 리턴해야 합니다.
*/

function addToFrontOfNew(arr, el) {
  // 수도코드
  // 시간이 없는 관계로 이하 생략
  
  let array = arr.slice(0);

  array.unshift(el)

  return array;

}


//----------------------------------------------------------------------------------------------------


/*
23_getAllElementsButNth
배열과 인덱스를 입력받아 해당 인덱스의 요소를 제외한 배열을 리턴해야 합니다.
*/

function getAllElementsButNth(arr, n) {
  // 수도코드
  // 시간이 없는 관계로 이하 생략

  arr.splice(n, 1);

  return arr;

}


//----------------------------------------------------------------------------------------------------


/*
24_createPhoneNumber
0-9 사이의 정수를 요소로 갖는 배열을 입력받아 전화번호 형식의 문자열을 리턴해야 합니다.
*/

function createPhoneNumber(arr) {
  // 수도코드
  // 시간이 없는 관계로 이하 생략

  let num = '';


  if(arr.length === 8){
    arr.splice(0,0,'(010)')
    arr.splice(5,0,'-')
  } else {
    arr.splice(0,0,'(')
    arr.splice(4,0,')')
    arr.splice(9,0,'-')
  }

  num = arr.join('');

  return num;
}


//----------------------------------------------------------------------------------------------------


/*
25_fibonacci
수(num)를 입력받아 num번째까지 총 num + 1개의 피보나치 수열을 리턴해야 합니다.

0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1입니다. 그 다음 2번째 피보나치 수부터는 바로 직전의 두 피보나치 수의 합으로 정의합니다.
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ...*/

function fibonacci(num) {
  // 수도코드
  // 반복한다 num + 1까지
  // 현재의 수와 과거의 수를 더한 값을 미래의 수에 저장한다.
  // 현재의 수는 미래의 수를 저장.
  // 과거의 수는 현재의 수를 저장.

  let past = 1;
  let present = 0;
  let future = 0
  let array = [0]

  for(let i = 0; i < num; i++){
    future = past + present;
    past = present;
    present = future;
    array.push(present)
  }

  return array;

}
